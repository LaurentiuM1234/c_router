============================= DISCLAMER ===================================
(*) this project was given to me as an assignment from the following
course: "Protocoale de comunicatii". As such, the implementations for some
of the features were already given to me by the team of TAs. I am in no
way trying to take credit for the work that is not mine.
===========================================================================

============================= DESCRIPTION =================================
(*) the main goal of this project is to better understand the way a router
manages its data-plane part. As such, this project represents a possible
implementation of the router's data-plane role, written purely in C.

(*) the "core" part of the project is found in the router.c file which is
the actual router implementation.

(*) using the scripts provided by the TA team, the project simulates
a simple topology(using mininet) comprised of two connected routers,
each of them having two hosts. Each of the simulated routers will run
the code found in router.c in order to forward the packets generated by
the hosts.
===========================================================================

============================= WORKFLOW ====================================
(*) STEPS:
	1) Check to see if the received packet contains the ARP header.
	If so, check to see if the packet is an arp request and send an
	ARP reply on the interface from which the packet came. If the
	packet is an ARP reply, add a new entry in the ARP table of the
	router with the data from the ARP reply, remove from the queue
	the IP address found in ARP reply's source field and send the
	packets which have the ARP reply's source IP address as next hop.
	   
	    COMMENTS: a) Since ARP is a L2 protocol, the host doesn't
		      send ARP requests towards the router interfaces
		      that are outside its LAN, so the router will
                      only respond with the MAC of the interface the
		      packet came on.

		      b) Due to the nature of the topology, there is
		      no need to check if the ARP request / reply is
		      for the router because the hosts can only send
		      ARP requests / replys to the routers they are
		      connected to.

		      c) I used a queue to store the IP addresses waiting
                      for an ARP reply so as to not "pollute" the network
                      with multiple ARP requests from the router in case
		      it doesn't immediatelly receive an ARP reply after
		      a packet whose destination IP address doesn't have
		      an entry in the ARP table.

	2) Check IP header checksum and throw packet if checksum is wrong.

	3) Check if TTL <= 1. If so, send ICMP_TIME_EXCEEDED to the
	packet's source on the interface the packet came and throw packet.

	4) Check if router has received an ICMP ECHO REQUEST on one of its
	interfaces and, if so, send back an ICMP ECHO REPLY on the
	interface the packet came on.

	5) Do a search in the routing table using Longest Prefix Match.
	If no route exists, send an ICMP_DEST_UNREACH on the interface
	the packet came on.

	6) Decrement the TTL, recalculate the checksum and update packet's
	@interface field with the interface found in the routing table's
	entry.

	7) Do a search in the ARP table for the MAC address of the next
	hop. If an entry was found, then the packet can be sent. If no
	entry was found, then check the queue of IP addresses that already
	have a pending ARP request and, if it's not there, add the address
	of the next hop. Add the current packet to the queue of pending
	packets in order to be able to resend it when an ARP reply is
	received at step 1.
===========================================================================

========================= USED DATA STRUCTURES ============================
(*) arraylist:
	- I used this data structure instead of a normal array because
	of its generic character and because it doesn't require a
	predefined size.

(*) tree:
	- I used a tree (combination between a heap and trie) to hold the
	information in the routing table in order to reduce the searching
	time from O(n) (using a standard array) to a constant time
	- for more informations, check [1]
===========================================================================


=============================== SOURCES ===================================
[1] Ideea for the tree data structure:
http://cial.csie.ncku.edu.tw/st2008/pdf/A_Longest_Prefix_First_Search_Tree_for_IP_Lookup.pd
===========================================================================



